/* Main.ino file generated by New Project wizard

   Created:   Thu Sep 5 2013
   Processor: ATmega2560
   Compiler:  Arduino AVR
*/

/*
  Dots Data: IO22 - IO27
  Cell Enable: I03 - I012
*/

/*  PS2Keyboard library example

  PS2Keyboard now requries both pins specified for begin()

  keyboard.begin(data_pin, irq_pin);

  Valid irq pins:
     Arduino:      2, 3
     Arduino Mega: 2, 3, 18, 19, 20, 21
     Teensy 1.0:   0, 1, 2, 3, 4, 6, 7, 16
     Teensy 2.0:   5, 6, 7, 8
     Teensy++ 1.0: 0, 1, 2, 3, 18, 19, 36, 37
     Teensy++ 2.0: 0, 1, 2, 3, 18, 19, 36, 37
     Sanguino:     2, 10, 11

  for more information you can read the original wiki in arduino.cc
  at http://www.arduino.cc/playground/Main/PS2Keyboard
  or http://www.pjrc.com/teensy/td_libs_PS2Keyboard.html

  Like the Original library and example this is under LGPL license.

  Modified by Cuninganreset@gmail.com on 2010-03-22
  Modified by Paul Stoffregen <paul@pjrc.com> June 2010
*/

#include <Keypad.h>
#include <PS2Keyboard.h>

const byte ROWS = 4; //three rows
const byte COLS = 3; //four columns
//define the symbols on the buttons of the keypads
char keyMap[ROWS][COLS] = {
  {'1', '2',  '3'},
  {'4', '5',  '6'},
  {'U', '0',  'D'},
  {'E', '0',  '0'},
};
byte rowPins[ROWS] = {22, 23, 24, 25}; //connect to the row pinouts of the keypad
byte colPins[COLS] = {26, 27, 28}; //connect to the column pinouts of the keypad

//initialize an instance of class NewKeypad
Keypad kpd = Keypad( makeKeymap(keyMap), rowPins, colPins, ROWS, COLS);

const int DataPin = 14;
const int IRQpin =  21;

PS2Keyboard keyboard;

const byte brailleDot[6] = {
  22, 23, 24, 25, 26, 27
};

const byte cellEnable[] = {
  3, 4, 5, 6, 7, 8, 9, 10, 11, 12
};

const byte keyPressDataPins[] = {
  30, 31, 32, 33, 34, 35, 36, 37
};

#define keyPressInterruptPin 21

#define nCells 10
#define nDots 6
#define nextLinePin 19
#define prevLinePin 20

// binary Braille Dot patters for ASCII from 32 to 122
// https://create.arduino.cc/projecthub/CesareBrizio/ascii-braille-real-time-translation-via-arduino-dd97a9
byte brailleCodes[] = {
  0,    14,   7,    2,    15,   15,   8,    13,
  28,   32,   40,   48,   52,   36,   56,   60,
  44,   24,   12,   10,   11,   32,   40,   48,
  52,   36,   56,   60,   44,   24,   28,   34,
  42,   50,   54,   38,   58,   62,   46,   26,
  30,   35,   43,   29,   51,   55,   39,   32,
  40,   48,   52,   36,   56,   60,   44,   24,
  28,   34,   42,   50,   54,   38,   58,   62,
  46,   26,   30,   35,   43,   29,   51,   55,
  39
};

byte asciiCodes[] = {
  32,   33,   34,   34,   40,   41,   44,   46,
  48,   49,   50,   51,   52,   53,   54,   55,
  56,   57,   58,   59,   63,   65,   66,   67,
  68,   69,   70,   71,   72,   73,   74,   75,
  76,   77,   78,   79,   80,   81,   82,   83,
  84,   85,   86,   87,   88,   89,   90,   97,
  98,   99,   100,  101,  102,  103,  104,  105,
  106,  107,  108,  109,  110,  111,  112,  113,
  114,  115,  116,  117,  118,  119,  120,  121,
  122
};
#define maxLines 10
byte ascii2Braille[255];
volatile boolean nextLine = false;
volatile boolean prevLine = false;
volatile boolean keyPress = false;
boolean t = false;
static unsigned long last_interrupt_time_nextLine = 0;
static unsigned long last_interrupt_time_prevLine = 0;
static unsigned long last_interrupt_time_keyPress = 0;

String textEng = "abcdefghijklmnopqrstuvwxyz0123456789";

String inputString = "";         // a String to hold incoming data
boolean stringComplete = false;  // whether the string is complete
byte nChars = textEng.length();
byte charIndexAtLineStart[maxLines];
byte line = 0;
byte charIndex = 0;
byte cellIndex = 0;

unsigned long loopCount;
unsigned long startTime;
String msg;

void setup()
{
  // put your setup code here, to run once:
  for (byte i = 0; i < nDots; i++)
    pinMode(brailleDot[i], OUTPUT);
  for (byte i = 0; i < nCells; i++)
    pinMode(cellEnable[i], OUTPUT);

  for (byte i = 0; i < 73; i++) {
    ascii2Braille[asciiCodes[i]] = brailleCodes[i];
  }

  for (byte i = 0; i < 8; i++) {
    pinMode(keyPressDataPins[i], INPUT);
  }
  Serial.begin(115200);
  keyboard.begin(DataPin, IRQpin);
  pinMode(nextLinePin, INPUT_PULLUP);
  pinMode(prevLinePin, INPUT_PULLUP);
  pinMode(keyPress, INPUT_PULLUP);
  pinMode(LED_BUILTIN, OUTPUT);
  attachInterrupt(digitalPinToInterrupt(nextLinePin), ISRNextLine, RISING);
  attachInterrupt(digitalPinToInterrupt(prevLinePin), ISRPrevLine, RISING);
  attachInterrupt(digitalPinToInterrupt(keyPressInterruptPin), ISRKeyPress, RISING);
  charIndexAtLineStart[line] = charIndex;
  displayTest();
  clearBraille();

  loopCount = 0;
  startTime = millis();
  msg = "";
}

void loopa() {
  while (!keyPress);
  keyPress = false;
  byte keyPressData = getKeyPressData();
  Serial.println("Key Press: '" + String(keyPressData, BIN) + "'");
}

void loop() {
  charIndex = charIndexAtLineStart[line];
  for (cellIndex = 0; (cellIndex < nCells) and (charIndex < nChars);) {
    byte c = textEng.charAt(charIndex++);
    if (isDigit(c)) {
      writeBraille(cellIndex++ % nCells, 0b00010111);
    }
    writeBraille(cellIndex++ % nCells, ascii2Braille[c]);
    //Serial.print(String(line) + "-" + String(charIndex) + "-" + char(c) + ", ");
    Serial.print(char(c));
  }
  Serial.println();
  Serial.println("Character: " + String(charIndex) + " of " + String(nChars) + ", Line: " + String(line + 1));
  while (!nextLine and !prevLine) {
    getKeyPress();
  }
  if (nextLine) {
    nextLine = false;
    if (charIndex < nChars) {
      line++;
      charIndexAtLineStart[line] = charIndex;
    }
    else
      getSerialData();
    //getKeyboardData();
  }

  else if (prevLine) {
    prevLine = false;
    if (line > 0) {
      line--;
    }
  }
  clearBraille();
}

void clearBraille() {
  for (byte j = 0; j < nCells; j++) {
    writeBraille(j, 0x00);
  }
}

void writeBraille(byte cellID, byte brailleCode) {
  digitalWrite(cellEnable[cellID], 1);
  for (int i = 0; i < nDots; i++) {
    digitalWrite(brailleDot[i], brailleCode >> i & 0x01);
  }
  digitalWrite(cellEnable[cellID], 0);
}

void ISRNextLine() {
  unsigned long interrupt_time = millis();
  if (interrupt_time - last_interrupt_time_nextLine > 200) {
    Serial.println("Next Line");
    nextLine = true;
  }
  last_interrupt_time_nextLine = interrupt_time;
}

void ISRPrevLine() {
  unsigned long interrupt_time = millis();
  if (interrupt_time - last_interrupt_time_prevLine > 200) {
    Serial.println("Prev Line");
    prevLine = true;
  }
  last_interrupt_time_prevLine = interrupt_time;
}

void ISRKeyPress() {
  unsigned long interrupt_time = millis();
  if (interrupt_time - last_interrupt_time_keyPress > 200) {
    Serial.println("Key Press");
    keyPress = true;
  }
  last_interrupt_time_keyPress = interrupt_time;
}

void getSerialData() {
  while (Serial.available()) {
    digitalWrite(LED_BUILTIN, t);
    t = !t;
    char inChar = (char)Serial.read();
    if (inChar == '\n') {
      textEng = inputString;
      nChars = textEng.length();
      line = 0;
      inputString = "";
    }
    else {
      inputString += inChar;
    }
  }
}

void getKeyboardData() {
  while (keyboard.available()) {
    digitalWrite(LED_BUILTIN, t);
    t = !t;
    char inChar = keyboard.read();
    if (inChar == 0x0D) {
      textEng = inputString;
      nChars = textEng.length();
      line = 0;
      inputString = "";
    }
    else {
      inputString += inChar;
    }
  }
  Serial.println("KB buffer: " + inputString);
  keyboard.clear();
}

void displayTest() {
  byte testPattern = 0x01;
  for (byte i  = 0; i < nCells; i++) {
    testPattern = 0x01;
    for (byte j = 0; j < nDots; j++) {
      writeBraille(i, testPattern << j);
      delay(50);
    }
    testPattern = 0x20;
    for (byte j = 0; j < nDots; j++) {
      writeBraille(i, testPattern >> j);
      delay(50);
    }
  }
  testPattern = 0x3F;
  for (byte i  = 0; i < nCells; i++) {
    writeBraille(i, testPattern);
  }
  delay(200);
}

byte getKeyPressData() {
  byte keyPressData = 0x00;

  for (byte i = 0; i < 8; i++) {
    keyPressData |= digitalRead(keyPressDataPins[i]) << i;
    Serial.println(digitalRead(keyPressDataPins[i]));
  }
  return 0xAA;

}

void getKeyPress() {
  loopCount++;
  if ( (millis() - startTime) > 5000 ) {
    Serial.print("Average loops per second = ");
    Serial.println(loopCount / 5);
    startTime = millis();
    loopCount = 0;
  }

  // Fills kpd.key[ ] array with up-to 10 active keys.
  // Returns true if there are ANY active keys.
  if (kpd.getKeys())
  {
    for (int i = 0; i < LIST_MAX; i++) // Scan the whole key list.
    {
      if ( kpd.key[i].stateChanged )   // Only find keys that have changed state.
      {
        switch (kpd.key[i].kstate) {  // Report active key state : IDLE, PRESSED, HOLD, or RELEASED
          case PRESSED:
            msg = " PRESSED.";
            break;
          case HOLD:
            msg = " HOLD.";
            break;
          case RELEASED:
            msg = " RELEASED.";
            break;
          case IDLE:
            msg = " IDLE.";
        }
        Serial.print("Key ");
        Serial.print(kpd.key[i].kchar);
        Serial.println(msg);
      }
    }
  }
}
